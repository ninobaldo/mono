\chapter{Análise de Rootkits e Técnicas Antiforense}

\citeonline{RH2006} define antiforense como método para prevenir ou agir contra a ciência usada a favor das leis civis e criminais que são aplicadas por órgãos como a polícia. \citeonline{BERI2007}, amplia essa ideia mostrando que é mais que uma técnica usada, é uma abordagem criminosa. 
Assim todas as tentativas de interferir na existência, quantidade e/ou qualidade da evidência de uma cena de crime, ou mesmo fazer a análise e exame das provas difíceis ou impossíveis de realizar, para \citeonline{ROG2005} será considerada antiforense. 
Dessa forma concluímos resumidamente que a antiforense computacional pode ser definida como qualquer ação praticada para obstruir, dificultar ou destruir evidências ou provas no âmbito computacional.

Dentre as modalidades de antiforense computacional, \citeonline{BH2009} as categoriza em cinco grandes grupos, veja a tabela \ref{tab:upx-comp}: 

 \begin{table}[htb]
  \centering  
  \begin{tabular}{|l|l|}
  \hline
	\textbf{Tipo}		& \textbf{Descrição}  \\ \hline
	Destruição de dados	& Destruir arquivos ou metadados \\ \hline
	Ocultação de dados	& Salvar arquivos em lugares incomuns ou não convencionais \\ \hline
	Corrupção de dados	& Compactação, criptografia ou mudar o seu \emph{file format} \\ \hline
	Fabricação de dados	& Introduzir \emph{known files} ou pistas falsas \\ \hline
	Não uso de disco	& Contracepção de dados ou injeção em memória \\ \hline
  \end{tabular}
  \caption{Tipos de antiforense \cite{BH2009}.}
  \label{tab:upx-comp}
\end{table}

Esses tipos serão apresentados durante as fases da análise \emph{post mortem}.

\section{Análise de Rootkits}

Na ciência forense computacional o corpo de delito quase sempre consiste em computadores e quando o perito vai realizar a coleta do material para a análise ele pode encontrar esse dispositivo ligado ou desligado. 
Quando o mesmo está ligado é possível realizar a análise viva, entretanto a análise \emph{live} de um ambiente com rootkit pode gerar dados falsos ou imprecisos.

Análise \emph{live} ou análise viva, consiste em uma análise focada em extrair e examinar dados voláteis \cite{MCDOUGAL2006}, esses dados voláteis são perdidos ao desligar o computador, como por exemplo, o conteúdo de registradores do processador, dados na \emph{cache}, dados na memória etc. 
Essa abordagem possui diversas vantagens entre elas estão extração de dados voláteis como já citado, triagem de equipamentos, triagem de dados, preservação de dados criptografados e a possibilidade de estabelecer flagrante \cite{FBC2011}.

É importante ressaltar que toda ferramenta ou \emph{hardware} utilizado para a coleta de dados em equipamentos que ainda estão em execução, vai depender de dados fornecidos pelo equipamento periciado, ou seja, em algum momento essas ferramentas forenses vão requisitar dados de um sistema comprometido e passível de alguma interceptação. \citeonline{JORUT2007} mostra que mesmo quando a solução utilizada para coleta é um hardware isso pode acontecer. 
Logo em um ambiente dominado por um rootkit não é um ambiente confiável, pois ele pode interceptar e alterar chamadas das ferramentas de análise, impossibilitando uma coleta real e fiel.

A metodologia empregada na análise de um ambiente supostamente com um rootkit varia muito, mas em termos gerais a análise \emph{post mortem} é menos arriscada.
As medidas antiforense que podem ser tomadas pelo rootkit dependem do ambiente de execução e engloba também a equipe que o administra. 

O melhor dos cenários para o atacante é quando o sistema é administrado por leigos, não capacitados, sobrecarregados e/ou os sistemas não são atualizados com frequência tornando mais fácil para o rootkit esconder-se.
No pior dos cenários o administradores são altamente qualificados, realizam rotinas frequentes e o ambiente esta sempre atualizado e auditorado \cite{BH2009}. 
Entender isso pode indicar ao perito o quão complexo o rootkit é, pois quanto mais próximo do pior cenário mais avançado tem que ser o rootkit o que pode caracterizar um \emph{Advanced persistent threat (APT)} ou ameaça avançada e persistente, ou seja, o ataque utilizando o rootkit foi orquestrado e planejado apenas para esse alvo específico.

Não existe técnica 100\% antiforense, então o objetivo do atacante é tornar a análise cansativa para induzir ao erro podendo adicionar inclusive falsos rootkits ou \emph{malwares} para despistar, iludir ou levar a conclusões precipitadas. Em \cite{BH2009} são mostrados passos para a análise \emph{Post mortem} onde se suspeita de rootkit: 

\begin{itemize}
  \item Clone do \emph{hard disk drive (HDD)};
  \item Recuperar arquivos;
  \item Coletar metadados dos arquivos;
  \item Retirar arquivos conhecidos;
  \item Análise estática dos executáveis suspeitos desconhecidos; e
  \item Análise dinâmica dos executáveis suspeitos.
\end{itemize}

Esses passos pode ser vistos como filtros, onde cada passo retira cada vez mais ruído, eliminando em cada etapa arquivos supérfluos. A seguir serão descritos cada um dos passos e as técnicas antiforenses que o perito pode enfrentar.

\section{Cópia forense do HDD}

A primeira fase e mais importante é a coleta, que nesse caso é clone do HDD. O clone do HDD, pode ser feito com software, como o DD\footnote{http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dd.html} ou por hardware específico para clonagem de HDDs. 
Por via de regra essas ferramentas são homologados por órgãos como \emph{National Institute of Standards and Technology (NIST)} que atestam a qualidade e eficácia dessas ferramentas em produzir cópias fidedignas que podem ser usadas em disputas legais como evidências. 

Basicamente todos essas ferramentas fazem cópias de setor por setor de todo o disco, para que o perito possa trabalhar nessa cópia preservando o HDD original.
Essas cópias já foram exaustivamente usadas em tribunais e são muito úteis e indispensáveis para a análise do perito. 
Hoje sua eficácia não é questionada, pois essa cópia ou clone tem os dados idênticos ao do HDD objeto de análise e essa igualdade pode ser atestada com \emph{checksums} como os algoritmo de \emph{hash} \emph{MD5} ou \emph{SHA1} \cite{MULVEY2007}.
Essa abordagem pode ter alguns empecilhos e o rootkit pode não vir a ser clonado junto com os dados do HDD.

Primeiro e mais óbvio é que o rootkit pode nem estar no disco clonado, como estar somente na memória ou ser alocado em um outro dispositivo.
O rootkit poder ser projetado para ficar somente na memória, contudo isso pode impedir que o mesmo persista já que é apagado sempre que o computador desliga \cite{PAROS2009}. 

Durante o \emph{boot} de um \emph{Personal Computer (PC)} moderno, o \emph{firmware} de \emph{boot} inicia o \emph{Basic Input/Output System (BIOS)} dando suporte básico para os principais periféricos como teclado e vídeo em modo texto.
Em seguida é iniciado o \emph{Power-On Self-Test (POST)} que além de realizar alguns testes inicia com base das configurações do SETUP salvas na memória CMOS todos os circuitos periféricos, vídeo em modo gráfico e passa o controle ao sistema operacional \cite{TORRES2001}. 

Durante todo esse processo o computador é executado em \emph{Real Mode}, sendo que em modo real os programas não são isolados uns dos outros como no \emph{Protected Mode}. 
Logo qualquer programa em execução pode acessar todo conteúdo na memória. 
O rootkit pode persistir no \emph{firmware}\footnote{Todo programa salvo numa \emph{Read-only memory (ROM)} é chamado de \emph{firmware}} de algum periférico, como a placa de vídeo \cite{NICDI2012} ou placa de rede \cite{ABME2012}, ou seja, ele irá executar antes do sistema operacional com todos os benefícios do modo real e tornar o clone do HDD inútil.

O perito deve ter em mente ainda que o rootkit pode estar em áreas reservadas do disco como \emph{host protected area (HPA)} ou \emph{Device configuration overlay (DCO)}, essas áreas são desenvolvidas para não serem modificadas ou mesmo acessadas por usuários, BIOS ou sistema operacional \cite{MMMP2006}. 
Dessa forma dependendo da ferramenta utilizada para clone do HDD pode ser que essas áreas não sejam clonadas (\cite{NIJENC2006} e \cite{NIJFTK2006}), inutilizando o clone do HDD.

Outro assunto que o perito deve se ater é ao que o disco clonado pode ter \emph{full disk encryption} o que significa que todos os dados no disco estão criptografados \cite{RUBENS2012} e que o clone também terá todos os dados criptografados. 
Logo o disco deverá ser descriptografados antes da análise.
Entretanto sendo improvável que um rootkit criptografe todo o disco da vítima, pois chamaria muita atenção e iria de encontro a uma de suas premissas que é se ocultar no sistema. 
Então quando disco está criptografado, ele provavelmente foi feito pela vítima e consequentemente a maior interessada no trabalho do perito facilitando a descriptografia do disco.

\section{Recuperar arquivos}

O próximo passo a ser tomado deve ser recuperar todos os arquivos do disco, isso incluí todos os arquivos \emph{Master Table File (MFT)} deletados ou não, seguido por \emph{data carving} com especial preocupação com: 

\begin{itemize}
  \item Assinaturas de executáveis;
  \item Fragmentos de arquivos;
  \item Data streams alternativos; e
  \item Slack space;
\end{itemize}

% Assinaturas de binários
Todos os arquivos tem um especificação que define o formato que o arquivo deve ter para ser corretamente interpretado, essas especificação define um padrão de como o \emph{bits} são organizados internamente e é chamado de \emph{file format} \cite{ROUSE2005}. 
Esse formato também é usado por ferramentas de \emph{data carving} para encontrar arquivos.
Por exemplo a especificação do \emph{Portable Executable (PE) File Format} \cite{MS2013} determina que todos os programas comecem com um pequeno executável \emph{MS-DOS}.
Esse pequeno executável inicia com o \emph{Magic Number} 0x5A4D ou \emph{MZ} em \emph{ASCII} (iniciais de Mark Zbikowski um dos arquitetos originais do MS-DOS \cite{PIETREK2002}), seguido de uma mensagem como pode ser vista na figura \ref{fig:cal-hex}.
A função desse pequeno programa é apresentar a mensagem ``This program cannot be run in DOS mode''. 

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.7]{figuras/cal-hex.png}
  \caption{Hexadecimal da Microsoft Calculator v. 5.1 visto no WinHex 16.3 SR-2}
  \label{fig:cal-hex}
\end{figure}

Programas que fazem \emph{data carving} buscam essas estruturas definidas para encontrar arquivos, mas o rootkit pode usar programas como o \emph{Transmogrify} do \emph{Metasploit Anti-Forensics Project (MAFIA)} que é capaz de mascarar um arquivo em qualquer assinatura \cite{MAYNOR2007}, de forma a deixar um executável no formato de um arquivo texto por exemplo.

Outra forma do rootkit esconde-se de um \emph{data carving} é utilizando-se de uma organização de arquivo não convencional, como usar fragmentos de diversos arquivos que só fazem sentido quando organizados de determinada forma, salvar seus arquivos em \emph{slack space} buscando e indexando-os em um \emph{file system} próprio \cite{CHUCK2007}, ou ainda usando \emph{features} de um sistema de arquivos como as \emph{streams} do NTFS \cite{IRBY2006}. 
Entretanto por mais eficiente que seja o método utilizado, o rootkit em algum momento tem que executar, logo em algum ponto o rootkit tem que trabalhar com estruturas convencionais para que o sistema operacional o interprete, mesmo que seja apenas um \emph{stub} (ver análise estática).

\section{Coletar metadados dos arquivos}

Nessa etapa é feita a coleta dos metadados de todos os arquivos, segue os principais:

\begin{itemize}
  \item Hash;
  \item MAC time;
  \item Nome;
  \item Localização completa do arquivo em disco (\emph{Path}); e
  \item Tamanho;
\end{itemize}

É importante que se tenha ao menos esses metadados dos arquivos recuperados.
Os próximos passos podem depender de um desses elementos. O \emph{hash} é fundamental para o próximo passo, o tamanho vai ser abordado na análise estática, o nome e \emph{path} são obviamente para sua identificação e para localização, e o \emph{MAC (Modify, Access, Create) time} pode vir a ser utilizado para desenvolver uma  \emph{timeline}, ferramenta útil e poderosa para favor do perito.

A análise da \emph{timeline} é um importante passo para todo processo tradicional de investigação, com base nela um perito forense computacional pode extrair informações cruciais para o caso \cite{KRISTINN2010}.
Criar uma \emph{timeline} de eventos com base nos \emph{MAC time} (figura \ref{fig:timestomp_mace}) dos arquivos ajuda a entender o ciclo de contaminação, além de levantar suspeitas sobre vários dados inconsistentes, como por exemplo, porque o papel de parede do Windows tem a data de modificação ou criação recente? Além de ajudar a entender como o rootkit pode ter se mantido no ambiente analisado.
Dessa forma é possível recriar a cadeia de eventos gerando ao mesmo tempo contexto.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=1]{figuras/Timestomp-mace.jpg}
  \caption{Arquivo com MAC time original \cite{IMGTIMEMC}}
  \label{fig:timestomp_mace}
\end{figure}

Para \citeonline{HALL2011} um dos principais desafios na análise de \emph{timeline} envolve a fácil manipulação. Para não levantar suspeitas, ou dificultar o processo de análise da \emph{timeline}, o rootkit pode ser programado a alterar o \emph{MAC time} quando necessário.
O programa \emph{Timestomp} também do \emph{MAFIA} e hoje integrado ao \emph{Meterpreter} é capaz de alterar esses metadados como é mostrado na figura \ref{fig:Timestomp_mace_change}.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=1]{figuras/Timestomp-mace-change.jpg}
  \caption{Utilização do timestomp \cite{IMGTIMEMC}}
  \label{fig:Timestomp_mace_change}
\end{figure}

%  outras referencias
% http://www.docstoc.com/docs/28703705/toorcon_vinnie_2005 timestomp
% http://www.ethicalhacker.net/forum/index.php?topic=5450.0;wap2
% http://www.explorehacking.com/2011/03/metasploit-tutorial-with-example.html

\section{Retirar arquivos conhecidos}

No passo anterior foram retirados \emph{hashes} dos arquivos encontrados e eles podem ser comparados com bases de hashes ou \emph{hashset} conhecidos, como os fornecidos pelo \emph{National Software Reference Library (NSRL)} \footnote{http://www.nsrl.nist.gov/Downloads.htm} fornecidos pelo NIST. 
Comparando os \emph{hashes} dos arquivos com \emph{hashset} de arquivos conhecidos é possível retirar todos os arquivos conhecidos maliciosos também conhecidos como \emph{known bad} ou arquivos inequivocamente bons (\emph{known good}) como os do sistema operacional, diminuindo o escopo que o perito deve trabalhar. 
O processo é bem simples, uma vez com o \emph{hashset} dos arquivos do disco investigado, o perito precisa apenas compara-los com os \emph{hashsets} de arquivos conhecidos.

Para evitar ou atrapalhar esse processo o rootkit teria que ter o mesmo \emph{hash} de um arquivo dito como bom. 
Seguindo os preceitos do paradoxo do aniversário que mostra a probabilidade de duas pessoas numa sala terem o mesmo aniversário, \citeonline{JEFF2011} apresenta a formula: $1 - e^{\frac{-k(k-1)}{2N}}$, onde N é a quantidade de valores distintos que o \emph{hash} pode apresentar e k é o tamanho do valor sequencial comparado, exemplo na sequencia: $0001_2$, $0010_2$, $0011_2$ e $0100_2$, o tamanho seria $0100_2$.
A tabela \ref{tab:hash-coll} mostra probabilidade de uma colisão de \emph{hash} numa repetição uniforme e sequencial.

\pagebreak

\begin{table}[htb]
  \centering  
  \begin{tabular}{|r|c|c|l|}
  \hline
      \textbf{32-bit} & \textbf{64-bit} & \textbf{160-bit} & \textbf{Probabilidades}\\ \hline
      77163 & 5,06 bilhões & $1,42x10^{24}$ & 50\% \\ \hline
    30084 & 1,97 bilhão & $5,55x10^{23}$ & 1 em 10 \\ \hline
    9292 & 609 milhões & $1,71x10^{23}$ & 1 em 100 ou um full house no poker \\ \hline
    10 & 607401 & $1,71x10^{20}$ & 1 em 100 milhões ou ser mordido por um tubarão \\ \hline
  \end{tabular}
  \caption{Probabilidade de uma colisão de hash em números sequenciais \cite{JEFF2011}.}
  \label{tab:hash-coll}
\end{table}

O \emph{hash} de um valor arbitrário (como o rootkit) coincidir com o \emph{hash} de um arquivo bom é improvável, contudo não impossível, como pode ser visto no trabalho dos chineses Xiaoyun Wang e Hongbo Yu da Universidade de Shandong em 2005 \cite{XIAOYUN2005}, no trabalho eles desenvolvem um algoritmo que pode ser usado para criar arquivos arbitrários com o mesmo \emph{hash} MD5, mas isso pode ser facilmente resolvido utilizando mais de um algoritmo como por exemplo SHA1 e MD5. 

Outra forma que o rootkit pode se valer para anular essa técnica, é alterar partes não significantes de arquivos do computador, como na mensagem mostrada do cabeçalho da \emph{PE}, pois mudar qualquer uma das letras da mensagem altera também o \emph{hash} do mesmo, contudo isso fugiria de uma regra básica dos rootkits que é ficar indetectável. No fim das contas esse método é recomendado por sua grande utilidade e dificilmente um rootkit tentará ou conseguirá perverte-lo, entretanto vale as ressalvas apresentadas.

% explica o attack http://www.codeproject.com/Articles/11643/Exploiting-MD5-collisions-in-C e http://www.mscs.dal.ca/~selinger/md5collision/

% http://www.wolframalpha.com/input/?i=birthday+attack&lk=1&a=ClashPrefs_*MathWorld.BirthdayAttack-
% http://www.wolframalpha.com/input/?i=birthday+problem&a=*C.birthday+problem-_*MathWorld-&a=FSelect_**BirthdayProblemWithLeapYear-.BirthdayProblem-&f3=23&f=BirthdayProblemWithLeapYear.n_23
% probabilidade (fazer tabela)  
% http://www.backupcentral.com/mr-backup-blog-mainmenu-47/13-mr-backup-blog/145-de-dupe-hash-collisions.html
% 
% mas nao impossivel ja que o MD5 foi quebrado ....
% http://www.mscs.dal.ca/~selinger/md5collision/ MD5 collision
%base de hash de arquivos conhecidos bons e ruins (assinatura de malwares conhecidos);
%

\section{Análise estática dos executáveis suspeitos desconhecidos}

Análise estática é a analise do código de determinado malware para se ter uma melhor compreensão sobre suas funções, características e objetivos \cite{DISTLER2007}. Depois de filtrar os arquivos conhecidos o perito deverá iniciar a análise estática de alguns arquivos suspeitos.
Certamente analisar todos os arquivos desconhecidos levaria muito tempo, inviabilizando na maioria dos casos a pericia. 

O ideal nesse momento é filtrar dentre os arquivos desconhecidos os que são potencialmente maliciosos, para isso o especialista deverá ficar atendo principalmente a binários.
Arquivos suspeitos são encontrados em todas as fases apresentadas, principalmente na recuperação de arquivos e na coleta de metadados, essas fases podem ajudar e muito a levantas suspeitas de arquivos, por exemplo, porque um arquivo de imagem com assinatura de jpg tem 2GB?

A fase onde são retirados os arquivos conhecidos, pode revelar programas conhecidamente maliciosos, esses arquivos podem ser investigados nessa fase também, para responder a pergunta primordial que é: esse código malicioso poderia subverter o(s) sistema(s) analisado? 
A resposta vai depender muito do tipo de ambiente analisado, pois se o ambiente for muito seguro, dificilmente uma ameaça qualquer conseguiria persistir, além do fato de que as chances de um rootkit \emph{APT} estar em qualquer base de arquivos conhecidos é mínima.

De qualquer forma apesar da resposta óbvia ser em sua grande maioria verdadeira, o perito não pode aceitá-la resoluto se apegando a qualquer evidência solta ou mal compreendida, porque existe a chance, mesmo que mínima de que o artefato malicioso encontrado tenha sido plantado. Esse texto percorre sobre rootkit e sempre tenderá ao pior dos cenários, contudo cautela e bom senso é vital.

\subsection{Packer}

A antiforense de processos de análise estática, consiste em impedir que os códigos do rootkit sejam analisados, para isso é comum que se use compreensão e criptografia nos arquivos do rootkit.
Essa compreensão e/ou criptografia utilizada em qualquer código, sendo ele malicioso ou não, mexe com a estrutura do arquivo e o torna irreconhecível, de modo que não pode ser executado normalmente. 
Técnicas como essa são muito utilizadas por \emph{malwares} para não serem detectados por antivírus, contudo sua aplicação também implica que sem uma estrutura padrão ele não pode ser interpretado pelo ambiente em que será executado e como já foi mostrado o rootkit em algum momento deverá ter uma estrutura padrão para que o mesmo possa ser executado.
Para resolver esse problema existe o \emph{stub} que será explicado abaixo.  

Um \emph{packer} é um programa que comprime um executável dentro de uma estrutura anormal e menor, de forma análoga a um programa de compactação de arquivos para o vulgarmente chamado \emph{zip} só que com executáveis.
Com \citeonline{PETRI2012} e \citeonline{BH2009} é possível entender como funciona um \emph{packer}, mas especificamente o \emph{Ultimate Packer for eXecutables (UPX)} \footnote{http://upx.sourceforge.net/} que é um \emph{packer} que suporta diversos tipos de executáveis de diversos ambientes como mostra a tabela \ref{tab:upx-comp}. 

\begin{table}[htb]
  \centering  
  \begin{tabular}{|l|l|}
  \hline
      \textbf{Nome completo} & \textbf{Descrição} \\ \hline
      amd64-linux.elf & Linux ELF \\ \hline
      arm-wince.pe & Windows CE executable or DLL \\ \hline
      fat-darwin.macho & Mac OS X executable \\ \hline
      i086-dos16.sys & DOS 16-bit .sys file \\ \hline
      i386-dos32.tmt.adam & DOS 32-bit executable \\ \hline
      i386-dos32.watcom.le & DOS 32-bit linear executable  \\ \hline
      i386-win32.pe & Windows 32-bit executable or DLL \\ \hline
  \end{tabular}
  \caption{Amostra de executáveis suportados pelo UPX \cite{UPX2013}.}
  \label{tab:upx-comp}
\end{table}

Ao lidar com executáveis Windows principalmente \emph{PE}, será encontrado uma estrutura com seções como .text, .data, .idata e .fill, como mostra a figura \ref{fig:pe-sections}.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.45]{figuras/pe-sections.png}
  \caption{Hello World - PIMAGE SECTION HEADER \cite{PETRI2012}}
  \label{fig:pe-sections}
\end{figure}

Depois de compactado o \emph{UPX}, deixa as seções do executável como o da figura \ref{fig:upx-sections}. O \emph{UPX} combina todas as seções .text, .data, .idata etc em uma única seções chamada upx1, onde tem uma \emph{stub} que descompacta o binário original.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{figuras/upx-sections.png}
  \caption{Packed Hello World - PIMAGE SECTION HEADER \cite{PETRI2012}}
  \label{fig:upx-sections}
\end{figure}

O que o \emph{UPX} faz é colocar o binário numa forma comprimida que o deixa com uma estrutura incomum ao ambiente de execução, logo as ferramentas de engenharia reversa como \emph{disassemblers} não conseguem interpretar e consequentemente o sistema operacional também não, contudo o \emph{UPX} também adiciona um executável capaz de descomprimir e executar o executável original em tempo de execução chamado de \emph{stub}.
O \emph{stub} descompacta o \emph{payload} que nesse caso é o executável original e muda o controle do executável para o \emph{entry point} do binário original. 

A seção upx0 é basicamente espaço vazio que ocuparão na memória, o upx1 é onde fica o \emph{stub} e o executável original compactado.
O \emph{stub} irá descompactar o executável original o inserindo no espaço vazio utilizado pela seção upx0 que ficam na \emph{low memory} e executado-o, dessa forma o \emph{stub} que fica logo acima na parte da memória também é sobrescrito durante o processo.

\subsection{Bytecode}

Outra forma de impossibilitar a análise estática, é compilar o rootkit em algum \emph{bytecode}, que são interpretados por alguma \emph{virtual machine} de forma análoga com código feito em Java e/ou .Net, ou seja, o código escrito em geral em uma linguagem de alto nível é compilado para algum tipo de \emph{bytecode}, conhecidos como o \emph{Java bytecode} ou o \emph{.Net bytecode}, ou até mesmo algum \emph{bytecode} privado.
Em qualquer uma dessas possibilidades, o ambiente que o mesmo ira ser executado deverá ter a \emph{virtual machine}, porque será ela que irá interpretar o \emph{bytecode} e traduzir para instruções que o processador compreende.

As complicações para o uso dessa abordagem envolve que necessariamente o criador do rootkit terá que utilizar uma \emph{virtual machine} para interpretar o \emph{bytecode} em tempo de execução, caso seja feito em algum \emph{bytecode} conhecido, o rootkit vai ser facilmente descompilado, mas se usar um \emph{bytecode} privado o mesmo irá ter que criar a \emph{virtual machine} privada também o que demanda muito tempo, mas em compensação dificulta muito o trabalho do perito, que antes de analisar o código terá que entender e descompilar a \emph{virtual machine}.
Da mesma forma que o código compactado, o código em \emph{bytecode} não possui instruções conhecidas, logo ferramentas ou até mesmo o processador não o interpreta. 

Esses foram dois métodos que podem ser utilizados para evitar ou complicar o processo de análise estática. Técnicas como essa podem ser usadas por programas legítimos também como é o caso do Skype \cite{NEEDLE2006}.
O importante é entender que não importa o que o rootkit pode usar, mas ele sempre vai ter que ter uma estrutura padrão para sua execução e que quanto mais baixo o nível de execução menos o rootkit pode fazer para se esconder, menos ele precisa efetivamente para se esconder e mais controle ele consegue do sobre o sistema infectado, por exemplo, se um rootkit roda desde a inicialização da \emph{BIOS}, quando o sistema operacional for executado o rootkit já está sendo executado.

\section{Análise dinâmica dos executáveis suspeitos}

As técnicas de antiforense mostradas na análise estática podem ser combinadas dificultando ainda mais a análise e tornar o trabalho tão demorado que é proibitivo continuar, contudo o \emph{stub} tem a chave para decodificar o binário, nesses casos a análise dinâmica pode acelerar o processo.
O objetivo da análise dinâmica é o mesmo da análise estática apesar dos métodos diferentes \cite{DISTLER2007}.

Existe muitas formas e técnicas aplicáveis a análises dinâmicas, como análise do tráfego, análise da memória, análise dos processos, análise do registro do Windows etc, essa análise é bem diferente da que pode ser feita no ambiente infectado (análise \emph{live}), mesmo que sejam usados técnicas e ferramentas bem parecida, porque a primeira, como já foi dito, o rootkit tem todas as vantagens e pode ter total controle sobre o ambiente ao contrário do segundo tipo que o perito prepara o ambiente e monitora. 
Nesse caso, quem chega primeiro tem todas as vantagens, seja o perito investigando um ambiente comprometido ou seja o rootkit executado em um ambiente preparado pelo perito.

Os \emph{packers} também são um empecilho nessa fase e tudo fica mais complicado quando é usado um \emph{packer} privado, pois nem todos se comportam como o \emph{UPX}, de forma que o \emph{packer} pode dividir o código em diversos seções e cada uma delas pode haver uma chave criptografada diferente ou então o rootkit pode ser programado para só executar no ambiente que ele infecta, por exemplo, ele pode usar verificações do hardware, ou ainda pode usar o \emph{hardware} como parte da senha para descompactar e/ou decriptar o binário original.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.5]{figuras/regiters.jpg}
  \caption{Registradores básicos IA32 \cite{WISMAN2012}}
  \label{fig:registers}
\end{figure}

O processador tem um registrador especial para \emph{flags} na arquitetura Intel de microprocessadores \emph{IA32} (figura \ref{fig:registers}), onde cada \emph{bit} desse registrador representa um \emph{flag} diferente.
A diferença principal entre um processo comum e um que está sendo depurado é que este possuí o \emph{bit 8} ou \emph{Trap Flag (TF)} setada no registrador de \emph{flags} chamado de \emph{EFLAGS} (veja a figura \ref{fig:eflag}). 

\begin{figure}[htb]
  \centering
  \includegraphics[scale=1]{figuras/eflags.png}
  \caption{Registrador EFLAGS IA32 \cite{WIKIDOT2010}}
  \label{fig:eflag}
\end{figure}

No modo de \emph{debug} o processador irá executar um instrução por vez, ignorando o paralelismo e \emph{pipeline} forçando um ciclo de processamento completo antes de executar a próxima instrução, desse jeito o processador permite que os registradores, memória e instruções possam ser verificadas a cada passo \cite{WIKIDOT2010}. 

O Windows tem métodos para verificar se o programa está sendo executado.
O \emph{ Windows SDK} possui duas rotinas, \emph{isDEBUggerPresent} em  \emph{user-mode} e \emph{KdRefreshDebuggerNotPresent} em  \emph{kernel-mode} \cite{NICOLAS2007}, ou seja, o rootkit tem como identificar se está sendo depurado.

O uso de \emph{virtual machines} facilitam muito o trabalho durante a análise.
Contudo existe também formas do rootkit verificar se está num ambiente virtualizado e não executar.
O rootkit pode ter todas essas técnicas para evitar ser analisado dinamicamente, contudo ele tem que executar de forma padrão.
Ele pode e provavelmente irá verificar se está em um ambientes virtualizado ou se está depurado durante a execução, fazendo com que o perito precise mudar o fluxo de execução para força-lo a executar em tais circunstancias.